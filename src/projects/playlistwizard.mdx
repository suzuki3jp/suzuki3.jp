---
title: "Playlist Wizard"
description: "Next.js と YouTube Data API, Spotify API を使用したプレイリスト管理ウェブアプリケーション"
tech: ["Next.js", "TypeScript", "shadcn/ui", "Tailwind CSS", "Vitest", "Biome"]
images:
    - "/playlistwizard/banner.png"
    - "/playlistwizard/home.png"
    - "/playlistwizard/playlists.png"
    - "/playlistwizard/playlist-browser.png"
    - "/playlistwizard/playlist-management-comparison.jpg"
status: "開発中"
startDate: "2024-10-17"
team: "個人開発"
featured: true
githubUrl: "https://github.com/suzuki3jp/playlistwizard"
liveUrl: "https://playlistwizard.suzuki3.jp/ja"
---

# Playlist Wizard

## プロジェクト概要
Playlist Wizard は、Next.js AppRouter, YouTube Data API v3, Spotify API を使用して、プレイリストを管理するためのウェブアプリケーションです。


## 主な機能
- **直感的なインターフェース**: プレイリスト管理のためのユーザーフレンドリーなGUI
- **プレイリスト管理**: プレイリストのコピー、シャッフル、マージ、抽出、削除
- **Undo機能（ベータ版）**: プレイリスト操作を安全に取り消し
- **プレイリストブラウザ**: プレイリスト項目の検索・閲覧
- **プレイリストインポート**: 他のユーザーが所有するプレイリストのインポート
- **マルチプラットフォーム**: 複数のプラットフォームをサポート（YouTube、YouTube Music、Spotify）
- **多言語対応**: 複数の言語で利用可能（英語、日本語）

## 開発のきっかけ
音楽サービスを使用する中で、その時の気分によって再生する音楽を分けるために複数のプレイリストを作成していました。
具体的には、TWICE, IU などのアーティストごとのプレイリストや、K-POP, J-POP などのジャンルごとのプレイリストを作成していました。

しかし、それらのプレイリストを管理する場合、以下のような課題を感じていました。

- 曲を追加する場合、複数のプレイリストに同じ曲を追加する必要があり、手間がかかる
- 新しいプレイリストを作成する際、既存のプレイリストから曲を選ぶ作業が煩雑
- 抜け落ちている曲を見つけることが困難

加えて、当時本格的な Web アプリケーションを作成したことがなく、Next.js や React などの技術的な興味もありました。

これらの課題と興味が重なり、Playlist Wizard の開発を始めました。Playlist Wizard は、プレイリストの管理をより簡単にし、音楽体験を向上させることを目指しています。

## 技術スタック

| 技術 | 採用理由等 |
|------|------|
| Next.js | AppRouter, SSR, Server Actions を活用して、効率的なデータ取得とページレンダリングを実現。 |
| TypeScript | 型安全な開発を行い、コードの品質と保守性を向上。 |
| shadcn/ui | プロジェクトにコードがコピーされる形式のため、カスタマイズ性が担保される。スタイル付きUIライブラリによる迅速な開発。 |
| Tailwind CSS | ユーティリティファーストのCSSフレームワークで、迅速なスタイリングとレスポンシブデザインを実現。 |
| Vitest | 高速なテストランナーで、ユニットテストを効率的に実行。 |
| Biome | 高速なコードフォーマッターとリンターで、コードの一貫性と品質を保つ。 |
| Vercel | Next.js とのシナジーの強いデプロイメントプラットフォームで、簡単にアプリケーションを公開。画像や静的ファイルの最適化も強力 |


## 技術的な挑戦
### Command パターンによるプレイリスト操作の Undo 機能
コピーやマージなどプレイリスト操作を取り消す Undo 機能を実装しました。
実装に当たっては、Command パターンを採用し、各操作をコマンドとして定義しました。これにより、操作の履歴を管理し、必要に応じて取り消すことが可能になりました。
しかし、API の制約により、Undo 中にAPIの呼び出しが失敗することがあり、完全な原子性を保証することはできませんでした。
### コード量が大きくなるに伴う保守性の低下
プロジェクトのコード量が大きくなるにつれ、保守性が急激に低下しました。
特に、プレイリストの操作、UI周りなどのコードが複雑化し、小さな変更でも多くの箇所に影響を与えるようになりました。

対策の方針を立てるために、整理する中で以下のような課題が見つかりました。
- **UI コンポーネントの肥大化**: プレイリスト操作のUIコンポーネントが複雑化し、再利用性が低下。
- **API 呼び出しの複雑化**: プレイリスト操作に伴うAPI呼び出しが増え、それらが UI コンポーネントに密結合しているため、テストが困難に。
- **テストの不足**: ユニットテストを導入していないため、コードの変更が他の部分に影響を与えるリスクが高い。

以上の課題を解決するために、以下のような変更を行いました

#### 1. クリーンアーキテクチャ、依存性逆転の原則の適用
以下の層に分割する クリーンアーキテクチャ（風）の構成を導入しました。
- **Presentation 層**: UI コンポーネントやプレゼンテーションロジックを担当。
- **Usecase 層**: プレイリスト操作のビジネスロジックを担当。
- **Repository 層**: API 呼び出しやデータ取得を担当。

Respository は Usecase 層で定義された Interface を実装する形（依存性逆転）にすることで、Usecase 層が Repository 層に依存しないようにしました。これにより、Usecase 層のテストが容易になり、Repository の実装を変更しても Usecase 層のコードに影響を与えないようにしました。
また、Repository が Usecase 層の Interface を実装する形にすることで、複数の API をサポートすることが容易になりました。

この構成により、現在２万行程度あるコードが、各層ごとに分割され、保守性が向上し、変更が容易に行えるようになりました。

#### 2. UI コンポーネントの分割と再利用性の向上
プレイリスト操作の UI コンポーネントを小さな再利用可能なコンポーネントに分割しました。これにより、各コンポーネントが単一の責任を持ち、テストや保守が容易になりました。

#### 3. API 呼び出しの抽象化
monorepo を導入し、API 呼び出しを専用のモジュールに分離しました。これにより、UI コンポーネントから API 呼び出しを切り離し、テスト可能な状態にしました。

#### 4. ユニットテストの導入
Vitest を使用して、ユニットテストを導入しました。特に、プレイリスト操作のコマンドや API 呼び出しのテストを重点的に行い、コードの信頼性を向上させました。また、CI にカバレッジを導入し、コードの品質を継続的に監視しています。現在のカバレッジは約 15% ですが、今後の開発で徐々に増やしていく予定です。

### 多言語対応
Google, Spotify などの API プロバイダの OAuth Client 審査を通過するために、アプリケーションの多言語対応を行いました。`i18next`, `react-i18next` を使用し、フックを実装することで、SSR, CSR ともに多言語を対応を実現しました。

## GitHub の運用
GitHub を使用して、プロジェクトのソースコードを管理しています。以下のような運用ルールを設けています。
- **ブランチ戦略**: `main` ブランチは常にデプロイされ、
  `develop` ブランチは開発中のコードを管理します。そして、機能ごとにブランチを切ります。
- **プルリクエスト**: マージの際には必ずプルリクエスト経由で行い、CI を通します。また、Vercel のプレビュービルドも走るため、Vercel 上での動作確認も行います。
- **CI**: GitHub Actions を使用して、フォーマット、リント、テストを自動化しています。これにより、コードの品質を保ちながら、開発の効率を向上させています。

## 成果と学び
初めての Next.js を活用した本格的なウェブアプリケーション開発で、試行錯誤しながら実装することで以下の学びを得ることができました。

#### Server Actions について
Server Actions を活用することで、Node.js でしか動作しないライブラリを使用しつつ、型安全に開発を進めることができました。

Server Actions を活用する中で、当初 プレイリストのコピー、マージ、などの粒度で Server Actions を定義していましたが、操作の進度を UI に反映するために、イベントハンドラのような関数を Server Actions の引数として渡したかったのですが、Server Actions の引数はプリミティブ型やオブジェクトに限られるため、実現できませんでした。

そのため、API リクエスト単体の Server Actions を定義し、コピーなどのロジックは Server Actions 外で実装することで、進度に応じた UI の更新を実現しました。

それらの経験から、Server Actions はユースケースによってはなるべく小さい粒度で定義することが望ましいと感じました。

#### アーキテクチャ、テストに関して
今までの個人開発ではここまでのコード量を管理したことがなかったということもあり、アーキテクチャやテストに関する意識がほぼありませんでした。

しかし、今回課題として挙げたような保守性の低下を経験し、アーキテクチャやテストの重要性を痛感しました。

## 今後の課題
- **パフォーマンスの最適化**: 現在の実装では、プレイリストが大きくなるにつれ、操作の実行時間が増加します。そのため、並列リクエストなどのパフォーマンス最適化を検討する必要があります。
- **操作の原子性**: API の制約もあり、完全な原子性は難しいとしても、リトライ機構などを改善することで、操作の信頼性を向上させる必要があります。
- **テストの充実**: 現在のカバレッジは約 15% ですが、今後の開発で徐々に増やしていく予定です。